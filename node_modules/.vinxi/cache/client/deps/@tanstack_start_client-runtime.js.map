{
  "version": 3,
  "sources": ["../../../../.pnpm/@tanstack+start@1.76.1_@types+node@22.7.8_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1___ef9092069f79f3b55405bc0b3508b65c/node_modules/@tanstack/start/src/client-runtime/fetcher.tsx", "../../../../.pnpm/@tanstack+start@1.76.1_@types+node@22.7.8_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1___ef9092069f79f3b55405bc0b3508b65c/node_modules/@tanstack/start/src/client-runtime/getBaseUrl.tsx", "../../../../.pnpm/@tanstack+start@1.76.1_@types+node@22.7.8_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1___ef9092069f79f3b55405bc0b3508b65c/node_modules/@tanstack/start/src/client-runtime/index.tsx"],
  "sourcesContent": ["import {\n  defaultStringifySearch,\n  isNotFound,\n  isPlainObject,\n  isRedirect,\n} from '@tanstack/react-router'\nimport {\n  serverFnPayloadTypeHeader,\n  serverFnReturnTypeHeader,\n} from '../constants'\nimport type { CompiledFetcherFnOptions } from '../client'\n\nexport async function fetcher<TPayload>(\n  base: string,\n  args: Array<any>,\n  handler: (request: Request) => Promise<Response>,\n) {\n  const first = args[0]\n\n  // If createServerFn was used to wrap the fetcher,\n  // We need to handle the arguments differently\n  if (isPlainObject(first) && first.method) {\n    const opts = first as CompiledFetcherFnOptions<TPayload>\n    const type =\n      opts.payload instanceof FormData\n        ? 'formData'\n        : opts.payload instanceof Request\n          ? 'request'\n          : 'payload'\n\n    // Arrange the headers\n    const headers = new Headers({\n      [serverFnPayloadTypeHeader]: type,\n      ...(type === 'payload'\n        ? {\n            'content-type': 'application/json',\n            accept: 'application/json',\n          }\n        : {}),\n      ...(opts.requestInit?.headers instanceof Headers\n        ? Object.fromEntries(opts.requestInit.headers.entries())\n        : opts.requestInit?.headers || {}),\n    })\n\n    // If the method is GET, we need to move the payload to the query string\n    if (opts.method === 'GET') {\n      // If the method is GET, we need to move the payload to the query string\n      const encodedPayload =\n        opts.payload !== undefined\n          ? defaultStringifySearch({\n              payload: opts.payload,\n            }).substring(1)\n          : ''\n\n      if (encodedPayload) base += `&${encodedPayload}`\n    }\n\n    // Create the request\n    const request = new Request(base, {\n      ...opts.requestInit,\n      method: opts.method,\n      headers,\n      ...(opts.method === 'POST'\n        ? {\n            body:\n              type === 'formData'\n                ? opts.payload\n                : (JSON.stringify(opts.payload ?? null) as any),\n          }\n        : {}),\n    })\n\n    const handlerResponse = await handler(request)\n\n    const response = await handleResponseErrors(handlerResponse)\n\n    if (['rsc'].includes(response.headers.get(serverFnReturnTypeHeader)!)) {\n      return response.body\n    }\n\n    if (['json'].includes(response.headers.get(serverFnReturnTypeHeader)!)) {\n      const text = await response.text()\n      const json = text ? JSON.parse(text) : undefined\n\n      // If the response is a redirect or not found, throw it\n      // for the router to handle\n      if (isRedirect(json) || isNotFound(json)) {\n        throw json\n      }\n\n      return json\n    }\n\n    return response\n  }\n\n  // If not a custom fetcher, just proxy the arguments\n  // through as a POST request\n  const request = new Request(base, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      [serverFnPayloadTypeHeader]: 'args',\n    },\n    body: JSON.stringify(args),\n  })\n\n  const response = await handleResponseErrors(await handler(request))\n\n  // If the response is JSON, return it parsed\n  const contentType = response.headers.get('content-type')\n  const text = await response.text()\n  if (contentType && contentType.includes('application/json')) {\n    return text ? JSON.parse(text) : undefined\n  } else {\n    // Otherwise, return the text as a fallback\n    // If the user wants more than this, they can pass a\n    // request instead\n    return text\n  }\n}\n\nasync function handleResponseErrors(response: Response) {\n  if (!response.ok) {\n    const contentType = response.headers.get('content-type')\n    const isJson = contentType && contentType.includes('application/json')\n\n    const body = await (async () => {\n      if (isJson) {\n        return await response.json()\n      }\n      return await response.text()\n    })()\n\n    const message = `Request failed with status ${response.status}`\n\n    if (isJson) {\n      throw new Error(\n        JSON.stringify({\n          message,\n          body,\n        }),\n      )\n    } else {\n      throw new Error(\n        [message, `${JSON.stringify(body, null, 2)}`].join('\\n\\n'),\n      )\n    }\n  }\n\n  return response\n}\n", "export function getBaseUrl(base: string | undefined, id: string, name: string) {\n  return `${base}/_server/?_serverFnId=${encodeURI(id)}&_serverFnName=${encodeURI(name)}`\n}\n", "import { fetcher } from './fetcher'\nimport { getBaseUrl } from './getBaseUrl'\nimport type { FetchFn } from '../client/createServerFn'\n\nexport function createServerReference<TPayload, TResponse>(\n  _fn: FetchFn<TPayload, TResponse>,\n  id: string,\n  name: string,\n) {\n  // let base = getBaseUrl(import.meta.env.SERVER_BASE_URL, id, name)\n  const base = getBaseUrl(window.location.origin, id, name)\n\n  const proxyFn = (...args: Array<any>) => fetcher(base, args, fetch)\n\n  return Object.assign(proxyFn, {\n    url: base,\n  })\n}\n\nexport { fetcher }\n"],
  "mappings": "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",
  "names": ["request", "response", "text"]
}
