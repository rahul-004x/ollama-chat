import {
  serverFnPayloadTypeHeader,
  serverFnReturnTypeHeader
} from "./chunk-256BUK2O.js";
import {
  defaultStringifySearch,
  isNotFound,
  isPlainObject,
  isRedirect
} from "./chunk-C454DNXS.js";
import "./chunk-EM6OVH4K.js";
import "./chunk-HLS4TUFV.js";
import "./chunk-XTFUJAKR.js";
import "./chunk-DC5AMYBS.js";

// node_modules/.pnpm/@tanstack+start@1.76.1_@types+node@22.7.8_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1___ef9092069f79f3b55405bc0b3508b65c/node_modules/@tanstack/start/dist/esm/client-runtime/fetcher.js
async function fetcher(base, args, handler) {
  var _a, _b;
  const first = args[0];
  if (isPlainObject(first) && first.method) {
    const opts = first;
    const type = opts.payload instanceof FormData ? "formData" : opts.payload instanceof Request ? "request" : "payload";
    const headers = new Headers({
      [serverFnPayloadTypeHeader]: type,
      ...type === "payload" ? {
        "content-type": "application/json",
        accept: "application/json"
      } : {},
      ...((_a = opts.requestInit) == null ? void 0 : _a.headers) instanceof Headers ? Object.fromEntries(opts.requestInit.headers.entries()) : ((_b = opts.requestInit) == null ? void 0 : _b.headers) || {}
    });
    if (opts.method === "GET") {
      const encodedPayload = opts.payload !== void 0 ? defaultStringifySearch({
        payload: opts.payload
      }).substring(1) : "";
      if (encodedPayload) base += `&${encodedPayload}`;
    }
    const request2 = new Request(base, {
      ...opts.requestInit,
      method: opts.method,
      headers,
      ...opts.method === "POST" ? {
        body: type === "formData" ? opts.payload : JSON.stringify(opts.payload ?? null)
      } : {}
    });
    const handlerResponse = await handler(request2);
    const response2 = await handleResponseErrors(handlerResponse);
    if (["rsc"].includes(response2.headers.get(serverFnReturnTypeHeader))) {
      return response2.body;
    }
    if (["json"].includes(response2.headers.get(serverFnReturnTypeHeader))) {
      const text2 = await response2.text();
      const json = text2 ? JSON.parse(text2) : void 0;
      if (isRedirect(json) || isNotFound(json)) {
        throw json;
      }
      return json;
    }
    return response2;
  }
  const request = new Request(base, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
      [serverFnPayloadTypeHeader]: "args"
    },
    body: JSON.stringify(args)
  });
  const response = await handleResponseErrors(await handler(request));
  const contentType = response.headers.get("content-type");
  const text = await response.text();
  if (contentType && contentType.includes("application/json")) {
    return text ? JSON.parse(text) : void 0;
  } else {
    return text;
  }
}
async function handleResponseErrors(response) {
  if (!response.ok) {
    const contentType = response.headers.get("content-type");
    const isJson = contentType && contentType.includes("application/json");
    const body = await (async () => {
      if (isJson) {
        return await response.json();
      }
      return await response.text();
    })();
    const message = `Request failed with status ${response.status}`;
    if (isJson) {
      throw new Error(
        JSON.stringify({
          message,
          body
        })
      );
    } else {
      throw new Error(
        [message, `${JSON.stringify(body, null, 2)}`].join("\n\n")
      );
    }
  }
  return response;
}

// node_modules/.pnpm/@tanstack+start@1.76.1_@types+node@22.7.8_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1___ef9092069f79f3b55405bc0b3508b65c/node_modules/@tanstack/start/dist/esm/client-runtime/getBaseUrl.js
function getBaseUrl(base, id, name) {
  return `${base}/_server/?_serverFnId=${encodeURI(id)}&_serverFnName=${encodeURI(name)}`;
}

// node_modules/.pnpm/@tanstack+start@1.76.1_@types+node@22.7.8_ioredis@5.4.1_react-dom@18.3.1_react@18.3.1___ef9092069f79f3b55405bc0b3508b65c/node_modules/@tanstack/start/dist/esm/client-runtime/index.js
function createServerReference(_fn, id, name) {
  const base = getBaseUrl(window.location.origin, id, name);
  const proxyFn = (...args) => fetcher(base, args, fetch);
  return Object.assign(proxyFn, {
    url: base
  });
}
export {
  createServerReference,
  fetcher
};
//# sourceMappingURL=@tanstack_start_client-runtime.js.map
