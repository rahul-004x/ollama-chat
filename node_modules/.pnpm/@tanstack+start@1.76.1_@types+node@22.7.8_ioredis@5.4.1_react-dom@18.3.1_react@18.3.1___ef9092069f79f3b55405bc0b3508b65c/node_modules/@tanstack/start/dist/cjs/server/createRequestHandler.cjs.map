{"version":3,"file":"createRequestHandler.cjs","sources":["../../../src/server/createRequestHandler.ts"],"sourcesContent":["import { createMemoryHistory } from '@tanstack/react-router'\nimport { serializeLoaderData } from '../client/serialization'\nimport {\n  mergeHeaders,\n  serverFnPayloadTypeHeader,\n  serverFnReturnTypeHeader,\n} from '../client'\nimport type { AnyRouter, Manifest } from '@tanstack/react-router'\nimport type { HandlerCallback } from './defaultStreamHandler'\n\nexport type RequestHandler<TRouter extends AnyRouter> = (\n  cb: HandlerCallback<TRouter>,\n) => Promise<Response>\n\nexport function createRequestHandler<TRouter extends AnyRouter>({\n  createRouter,\n  request,\n  getRouterManifest,\n}: {\n  createRouter: () => TRouter\n  request: Request\n  getRouterManifest?: () => Manifest\n}): RequestHandler<TRouter> {\n  return async (cb) => {\n    const router = createRouter()\n\n    // Inject a few of the SSR helpers and defaults\n    router.serializeLoaderData = serializeLoaderData as any\n\n    if (getRouterManifest) {\n      router.manifest = getRouterManifest()\n    }\n\n    const url = new URL(request.url, 'http://localhost')\n\n    const href = url.href.replace(url.origin, '')\n\n    // Create a history for the router\n    const history = createMemoryHistory({\n      initialEntries: [href],\n    })\n\n    // Update the router with the history and context\n    router.update({\n      history,\n    })\n\n    await router.load()\n\n    const responseHeaders = getRequestHeaders({\n      router,\n    })\n\n    return cb({\n      request,\n      router,\n      responseHeaders,\n    } as any)\n  }\n}\n\nfunction getRequestHeaders(opts: { router: AnyRouter }): Headers {\n  let headers = mergeHeaders(\n    {\n      'Content-Type': 'text/html; charset=UTF-8',\n    },\n    ...opts.router.state.matches.map((match) => {\n      return match.headers\n    }),\n  )\n\n  // Handle Redirects\n  const { redirect } = opts.router.state\n\n  if (redirect) {\n    headers = mergeHeaders(headers, redirect.headers, {\n      Location: redirect.href,\n    })\n  }\n\n  // Remove server function headers\n  ;[serverFnReturnTypeHeader, serverFnPayloadTypeHeader].forEach((header) => {\n    headers.delete(header)\n  })\n\n  return headers\n}\n"],"names":["serializeLoaderData","createMemoryHistory","headers","mergeHeaders","serverFnReturnTypeHeader","serverFnPayloadTypeHeader"],"mappings":";;;;;;AAcO,SAAS,qBAAgD;AAAA,EAC9D;AAAA,EACA;AAAA,EACA;AACF,GAI4B;AAC1B,SAAO,OAAO,OAAO;AACnB,UAAM,SAAS;AAGf,WAAO,sBAAsBA;AAE7B,QAAI,mBAAmB;AACrB,aAAO,WAAW;IACpB;AAEA,UAAM,MAAM,IAAI,IAAI,QAAQ,KAAK,kBAAkB;AAEnD,UAAM,OAAO,IAAI,KAAK,QAAQ,IAAI,QAAQ,EAAE;AAG5C,UAAM,UAAUC,YAAAA,oBAAoB;AAAA,MAClC,gBAAgB,CAAC,IAAI;AAAA,IAAA,CACtB;AAGD,WAAO,OAAO;AAAA,MACZ;AAAA,IAAA,CACD;AAED,UAAM,OAAO;AAEb,UAAM,kBAAkB,kBAAkB;AAAA,MACxC;AAAA,IAAA,CACD;AAED,WAAO,GAAG;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACM;AAAA,EAAA;AAEZ;AAEA,SAAS,kBAAkB,MAAsC;AAC/D,MAAIC,YAAUC,QAAA;AAAA,IACZ;AAAA,MACE,gBAAgB;AAAA,IAClB;AAAA,IACA,GAAG,KAAK,OAAO,MAAM,QAAQ,IAAI,CAAC,UAAU;AAC1C,aAAO,MAAM;AAAA,IAAA,CACd;AAAA,EAAA;AAIH,QAAM,EAAE,SAAa,IAAA,KAAK,OAAO;AAEjC,MAAI,UAAU;AACFD,gBAAAC,QAAA,aAAaD,WAAS,SAAS,SAAS;AAAA,MAChD,UAAU,SAAS;AAAA,IAAA,CACpB;AAAA,EACH;AAGC,GAACE,UAA0B,0BAAAC,UAAyB,yBAAA,EAAE,QAAQ,CAAC,WAAW;AACzEH,cAAQ,OAAO,MAAM;AAAA,EAAA,CACtB;AAEM,SAAAA;AACT;;"}