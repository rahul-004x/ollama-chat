"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("react/jsx-runtime");
const node_stream = require("node:stream");
const isbot = require("isbot");
const ReactDOMServer = require("react-dom/server");
const StartServer = require("./StartServer.cjs");
const transformStreamWithRouter = require("./transformStreamWithRouter.cjs");
const defaultStreamHandler = async ({
  request,
  router,
  responseHeaders
}) => {
  if (typeof ReactDOMServer.renderToReadableStream === "function") {
    const stream = await ReactDOMServer.renderToReadableStream(
      /* @__PURE__ */ jsxRuntime.jsx(StartServer.StartServer, { router }),
      {
        signal: request.signal,
        onError(error, errorInfo) {
          console.error(error, errorInfo);
        }
      }
    );
    if (isbot.isbot(request.headers.get("User-Agent"))) {
      await stream.allReady;
    }
    const transforms = [transformStreamWithRouter.transformReadableStreamWithRouter(router)];
    const transformedStream = transforms.reduce(
      (stream2, transform) => stream2.pipeThrough(transform),
      stream
    );
    return new Response(transformedStream, {
      status: router.state.statusCode,
      headers: responseHeaders
    });
  }
  if (typeof ReactDOMServer.renderToPipeableStream === "function") {
    const passthrough = new node_stream.PassThrough();
    const pipeable = ReactDOMServer.renderToPipeableStream(
      /* @__PURE__ */ jsxRuntime.jsx(StartServer.StartServer, { router }),
      {
        ...isbot.isbot(request.headers.get("User-Agent")) ? {
          onAllReady() {
            pipeable.pipe(passthrough);
          }
        } : {
          onShellReady() {
            pipeable.pipe(passthrough);
          }
        },
        onShellError(err) {
          throw err;
        }
      }
    );
    const transforms = [transformStreamWithRouter.transformStreamWithRouter(router)];
    const transformedStream = transforms.reduce(
      (stream, transform) => stream.pipe(transform),
      passthrough
    );
    return new Response(transformedStream, {
      status: router.state.statusCode,
      headers: responseHeaders
    });
  }
  throw new Error(
    "No renderToReadableStream or renderToPipeableStream found in react-dom/server. Ensure you are using a version of react-dom that supports streaming."
  );
};
exports.defaultStreamHandler = defaultStreamHandler;
//# sourceMappingURL=defaultStreamHandler.cjs.map
