"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const node_stream = require("node:stream");
function transformStreamWithRouter(router) {
  const callbacks = transformHtmlCallbacks(
    () => router.injectedHtml.map((d) => d()).join("")
  );
  return new node_stream.Transform({
    transform(chunk, _encoding, callback) {
      callbacks.transform(chunk, this.push.bind(this)).then(() => callback()).catch((err) => callback(err));
    },
    flush(callback) {
      callbacks.flush(this.push.bind(this)).then(() => callback()).catch((err) => callback(err));
    }
  });
}
function transformReadableStreamWithRouter(router) {
  const callbacks = transformHtmlCallbacks(
    () => router.injectedHtml.map((d) => d()).join("")
  );
  const encoder = new TextEncoder();
  return new TransformStream({
    transform(chunk, controller) {
      return callbacks.transform(chunk, (chunkToPush) => {
        controller.enqueue(encoder.encode(chunkToPush));
        return true;
      });
    },
    flush(controller) {
      return callbacks.flush((chunkToPush) => {
        controller.enqueue(chunkToPush);
        return true;
      });
    }
  });
}
const patternBodyStart = /(<body)/;
const patternBodyEnd = /(<\/body>)/;
const patternHtmlEnd = /(<\/html>)/;
const pattern = /(<\/[a-zA-Z][\w:.-]*?>)/g;
const textDecoder = new TextDecoder();
function transformHtmlCallbacks(getHtml) {
  let bodyStarted = false;
  let leftover = "";
  let leftoverHtml = "";
  return {
    // eslint-disable-next-line @typescript-eslint/require-await
    async transform(chunk, push) {
      const chunkString = leftover + textDecoder.decode(chunk);
      const bodyStartMatch = chunkString.match(patternBodyStart);
      const bodyEndMatch = chunkString.match(patternBodyEnd);
      const htmlEndMatch = chunkString.match(patternHtmlEnd);
      try {
        if (bodyStartMatch) {
          bodyStarted = true;
        }
        if (!bodyStarted) {
          push(chunkString);
          leftover = "";
          return;
        }
        const html = getHtml();
        if (bodyEndMatch && htmlEndMatch && bodyEndMatch.index < htmlEndMatch.index) {
          const bodyIndex = bodyEndMatch.index + bodyEndMatch[0].length;
          const htmlIndex = htmlEndMatch.index + htmlEndMatch[0].length;
          const processed = chunkString.slice(0, bodyIndex) + html + chunkString.slice(bodyIndex, htmlIndex) + chunkString.slice(htmlIndex);
          push(processed);
          leftover = "";
        } else {
          let result;
          let lastIndex = 0;
          while ((result = pattern.exec(chunkString)) !== null) {
            lastIndex = result.index + result[0].length;
          }
          if (lastIndex > 0) {
            const processed = chunkString.slice(0, lastIndex) + html + leftoverHtml;
            push(processed);
            leftover = chunkString.slice(lastIndex);
          } else {
            leftover = chunkString;
            leftoverHtml += html;
          }
        }
      } catch (err) {
        console.error(err);
        throw err;
      }
    },
    // eslint-disable-next-line @typescript-eslint/require-await
    async flush(push) {
      if (leftover) {
        push(leftover);
      }
    }
  };
}
exports.transformReadableStreamWithRouter = transformReadableStreamWithRouter;
exports.transformStreamWithRouter = transformStreamWithRouter;
//# sourceMappingURL=transformStreamWithRouter.cjs.map
