{"version":3,"file":"index.cjs","sources":["../../../src/server-runtime/index.tsx"],"sourcesContent":["import { Readable, Writable } from 'node:stream'\nimport { getEvent, getRequestHeaders } from 'vinxi/http'\nimport { fetcher } from '../client-runtime/fetcher'\nimport { getBaseUrl } from '../client-runtime/getBaseUrl'\nimport { handleServerRequest } from '../server-handler/index'\nimport type { WritableOptions } from 'node:stream'\nimport type { FetchFn } from '../client/createServerFn'\n/**\n *\n * @returns {import('node:http').IncomingMessage}\n */\nexport function createIncomingMessage(\n  url: string,\n  method: string,\n  headers: HeadersInit,\n): Readable {\n  const readable = new Readable({ objectMode: true }) as any\n  readable._read = () => {}\n\n  readable.url = url\n  readable.method = method\n  readable.headers = headers\n  readable.connection = {}\n  readable.getHeaders = () => {\n    return headers\n  }\n  return readable\n}\n\nfunction createAsyncStream(options?: WritableOptions) {\n  let firstActivity = false\n  let resolveActivity: () => void\n  let finishActivity: () => void\n\n  const initialPromise = new Promise<void>((resolve) => {\n    resolveActivity = resolve\n  })\n\n  const finishPromise = new Promise<void>((resolve) => {\n    finishActivity = resolve\n  })\n\n  const readable = new Readable({\n    objectMode: true,\n  })\n\n  readable._read = () => {}\n\n  const writable = new Writable({\n    ...options,\n    write(chunk, encoding, callback) {\n      if (!firstActivity) {\n        firstActivity = true\n        resolveActivity()\n      }\n      readable.push(chunk, encoding)\n      callback()\n    },\n  }) as any\n\n  const headers = new Headers()\n\n  writable.setHeader = (key: string, value: string) => {\n    headers.set(key, value)\n  }\n\n  writable.on('finish', () => {\n    readable.push(null)\n    readable.destroy()\n    finishActivity()\n  })\n\n  return {\n    readable,\n    writable,\n    headers,\n    initialPromise,\n    finishPromise,\n  } as const\n}\n\nexport function createServerReference<TPayload, TResponse>(\n  _fn: FetchFn<TPayload, TResponse>,\n  id: string,\n  name: string,\n) {\n  const functionUrl = getBaseUrl('http://localhost:3000', id, name)\n\n  const proxyFn = (...args: Array<any>) =>\n    fetcher(functionUrl, args, async (request) => {\n      const event = getEvent()\n\n      const ogRequestHeaders = getRequestHeaders(event)\n\n      Object.entries(ogRequestHeaders).forEach(([key, value]) => {\n        if (!request.headers.has(key)) {\n          request.headers.append(key, value!)\n        }\n      })\n\n      //   // For RSC, we need to proxy this request back to the server under\n      //   // the /_server path and let the RSC/Server-fn router handle it\n      // if (RSC) {\n\n      //   const incomingMessage = createIncomingMessage(\n      //     new URL(request.url).pathname + new URL(request.url).search,\n      //     request.method,\n      //     Object.fromEntries(request.headers.entries()),\n      //   )\n\n      //   const asyncStream = createAsyncStream()\n\n      //   const result = await handleHTTPEvent(\n      //     new H3Event(incomingMessage as any, asyncStream.writable),\n      //   )\n\n      //   console.info('awaiting initial promise', result, asyncStream)\n\n      //   await asyncStream.initialPromise\n\n      //   // Only augment the headers of the underlying document request\n      //   // if the response headers have not been sent yet\n      //   if (!(event as any).__tsrHeadersSent) {\n      //     const ogResponseHeaders = getResponseHeaders(event)\n\n      //     asyncStream.headers.forEach((value, key) => {\n      //       if (!Object.hasOwn(ogResponseHeaders, key)) {\n      //         ogResponseHeaders[key] = value\n      //       }\n      //     })\n\n      //     setResponseHeaders(event, ogResponseHeaders as any)\n      //   }\n\n      //   console.info(asyncStream.readable)\n\n      //   // if (asyncStream.headers.get('content-type') === 'application/json') {\n      //   //   await asyncStream.finishPromise\n      //   // }\n\n      //   return new Response(Readable.toWeb(asyncStream.readable) as any, {\n      //     headers: asyncStream.headers,\n      //   })\n      // }\n\n      // For now, we're not doing RSC, so we just handle the request\n      // in the current non-worker scope\n      return handleServerRequest(request, event)\n    })\n\n  return Object.assign(proxyFn, {\n    url: functionUrl,\n  })\n}\n"],"names":["Readable","getBaseUrl","fetcher","getEvent","getRequestHeaders","handleServerRequest"],"mappings":";;;;;;;AAWgB,SAAA,sBACd,KACA,QACA,SACU;AACV,QAAM,WAAW,IAAIA,YAAA,SAAS,EAAE,YAAY,KAAM,CAAA;AAClD,WAAS,QAAQ,MAAM;AAAA,EAAA;AAEvB,WAAS,MAAM;AACf,WAAS,SAAS;AAClB,WAAS,UAAU;AACnB,WAAS,aAAa;AACtB,WAAS,aAAa,MAAM;AACnB,WAAA;AAAA,EAAA;AAEF,SAAA;AACT;AAsDgB,SAAA,sBACd,KACA,IACA,MACA;AACA,QAAM,cAAcC,WAAA,WAAW,yBAAyB,IAAI,IAAI;AAEhE,QAAM,UAAU,IAAI,SAClBC,gBAAQ,aAAa,MAAM,OAAO,YAAY;AAC5C,UAAM,QAAQC,KAAAA;AAER,UAAA,mBAAmBC,uBAAkB,KAAK;AAEzC,WAAA,QAAQ,gBAAgB,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACzD,UAAI,CAAC,QAAQ,QAAQ,IAAI,GAAG,GAAG;AACrB,gBAAA,QAAQ,OAAO,KAAK,KAAM;AAAA,MACpC;AAAA,IAAA,CACD;AAiDM,WAAAC,MAAAA,oBAAoB,OAAc;AAAA,EAAA,CAC1C;AAEI,SAAA,OAAO,OAAO,SAAS;AAAA,IAC5B,KAAK;AAAA,EAAA,CACN;AACH;;;"}