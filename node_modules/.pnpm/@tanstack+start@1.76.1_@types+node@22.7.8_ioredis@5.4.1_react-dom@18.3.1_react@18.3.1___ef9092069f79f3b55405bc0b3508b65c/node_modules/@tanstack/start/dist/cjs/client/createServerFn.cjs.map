{"version":3,"file":"createServerFn.cjs","sources":["../../../src/client/createServerFn.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport type FetcherOptionsBase = {\n  method?: 'GET' | 'POST'\n}\n\nexport type FetcherOptions = FetcherOptionsBase & {\n  requestInit?: RequestInit\n}\n\nexport type FetchFnCtx = {\n  method: 'GET' | 'POST'\n  request: Request\n}\n\nexport type FetchFn<TPayload, TResponse> = {\n  (payload: TPayload, ctx: FetchFnCtx): Promise<TResponse> | TResponse\n  url?: string\n}\n\nexport type CompiledFetcherFnOptions<TPayload> = {\n  method: 'GET' | 'POST'\n  payload: TPayload | undefined\n  requestInit?: RequestInit\n}\n\nexport type CompiledFetcherFn<TPayload, TResponse> = {\n  (opts: CompiledFetcherFnOptions<TPayload>): Promise<TResponse>\n  url: string\n}\n\ntype IsPayloadOptional<T> = [T] extends [undefined] ? true : false\n\nexport type Fetcher<TPayload, TResponse> =\n  (IsPayloadOptional<TPayload> extends true\n    ? (\n        payload?: TPayload,\n        opts?: FetcherOptions,\n      ) => Promise<FetcherPayload<TResponse>>\n    : (\n        payload: TPayload,\n        opts?: FetcherOptions,\n      ) => Promise<FetcherPayload<TResponse>>) & {\n    url: string\n  }\n\nexport type FetcherPayload<TResponse> = WrapRSCs<\n  TResponse extends JsonResponse<infer TData> ? TData : TResponse\n>\n\ntype WrapRSCs<T> = T extends JSX.Element\n  ? ReadableStream\n  : T extends Record<string, any>\n    ? {\n        [K in keyof T]: WrapRSCs<T[K]>\n      }\n    : T extends Array<infer U>\n      ? Array<WrapRSCs<U>>\n      : T\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport function createServerFn<\n  TMethod extends 'GET' | 'POST',\n  TPayload = undefined,\n  TResponse = unknown,\n>(\n  method: TMethod,\n  fn: FetchFn<TPayload, TResponse>,\n): Fetcher<TPayload, TResponse> {\n  // Cast the compiled function that will be injected by vinxi\n  const compiledFn = fn as unknown as CompiledFetcherFn<TPayload, TResponse>\n\n  invariant(\n    compiledFn.url,\n    `createServerFn must be called with a function that is marked with the 'use server' pragma. Are you using the @tanstack/router-plugin/vite ?`,\n  )\n\n  return Object.assign(\n    async (payload: TPayload, opts?: FetcherOptions) => {\n      return compiledFn({\n        method,\n        payload: payload || undefined,\n        requestInit: opts?.requestInit,\n      })\n    },\n    {\n      url: fn.url!,\n    },\n  ) as Fetcher<TPayload, TResponse>\n}\n"],"names":[],"mappings":";;;AAoEgB,SAAA,eAKd,QACA,IAC8B;AAE9B,QAAM,aAAa;AAEnB;AAAA,IACE,WAAW;AAAA,IACX;AAAA,EAAA;AAGF,SAAO,OAAO;AAAA,IACZ,OAAO,SAAmB,SAA0B;AAClD,aAAO,WAAW;AAAA,QAChB;AAAA,QACA,SAAS,WAAW;AAAA,QACpB,aAAa,6BAAM;AAAA,MAAA,CACpB;AAAA,IACH;AAAA,IACA;AAAA,MACE,KAAK,GAAG;AAAA,IACV;AAAA,EAAA;AAEJ;;"}