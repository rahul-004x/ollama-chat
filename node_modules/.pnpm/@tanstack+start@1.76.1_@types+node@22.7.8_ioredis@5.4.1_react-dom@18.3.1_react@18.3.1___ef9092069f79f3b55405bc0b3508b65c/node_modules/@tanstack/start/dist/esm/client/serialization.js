import { jsxs, Fragment, jsx } from "react/jsx-runtime";
import * as React from "react";
import { useRouter, ScriptOnce, pick, isPlainArray, isPlainObject, defer, createControlledPromise } from "@tanstack/react-router";
import jsesc from "jsesc";
import invariant from "tiny-invariant";
function serializeLoaderData(dataType, data, ctx) {
  if (!ctx.router.isServer) {
    return data;
  }
  ctx.match.extracted = ctx.match.extracted || [];
  const extracted = ctx.match.extracted;
  const replacedLoaderData = replaceBy(data, (value, path) => {
    const type = value instanceof ReadableStream ? "stream" : value instanceof Promise ? "promise" : void 0;
    if (type) {
      const entry = {
        dataType,
        type,
        path,
        id: extracted.length,
        value,
        matchIndex: ctx.match.index
      };
      extracted.push(entry);
      if (type === "stream") {
        const [copy1, copy2] = value.tee();
        entry.streamState = createStreamState({ stream: copy2 });
        return copy1;
      } else {
        defer(value);
      }
    }
    return value;
  });
  return replacedLoaderData;
}
function afterHydrate({ router }) {
  router.state.matches.forEach((match) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const route = router.looseRoutesById[match.routeId];
    const dMatch = (_a = window.__TSR__) == null ? void 0 : _a.matches[match.index];
    if (dMatch) {
      const parentMatch = router.state.matches[match.index - 1];
      const parentContext = (parentMatch == null ? void 0 : parentMatch.context) ?? router.options.context ?? {};
      if (dMatch.__beforeLoadContext) {
        match.__beforeLoadContext = router.options.transformer.parse(
          dMatch.__beforeLoadContext
        );
        match.context = {
          ...parentContext,
          ...match.context,
          ...match.__beforeLoadContext
        };
      }
      if (dMatch.loaderData) {
        match.loaderData = router.options.transformer.parse(dMatch.loaderData);
      }
      const extracted = dMatch.extracted;
      if (extracted) {
        Object.entries(extracted).forEach(([_, ex]) => {
          if (ex.value instanceof Promise) {
            const og = ex.value;
            ex.value = og.then((data) => {
              return data;
            });
          }
          deepMutableSetByPath(match, ["loaderData", ...ex.path], ex.value);
        });
      }
    }
    const meta = match.status === "success" ? (_c = (_b = route.options).meta) == null ? void 0 : _c.call(_b, {
      matches: router.state.matches,
      match,
      params: match.params,
      loaderData: match.loaderData
    }) : void 0;
    Object.assign(match, {
      meta,
      links: (_e = (_d = route.options).links) == null ? void 0 : _e.call(_d),
      scripts: (_g = (_f = route.options).scripts) == null ? void 0 : _g.call(_f)
    });
  });
}
function AfterEachMatch(props) {
  const router = useRouter();
  const fullMatch = router.state.matches[props.matchIndex];
  if (!router.isServer) {
    return null;
  }
  const extracted = fullMatch.extracted;
  const [serializedBeforeLoadData, serializedLoaderData] = ["__beforeLoadContext", "loaderData"].map((dataType) => {
    return extracted ? extracted.reduce(
      (acc, entry) => {
        if (entry.dataType !== dataType) {
          return deepImmutableSetByPath(
            acc,
            ["temp", ...entry.path],
            void 0
          );
        }
        return acc;
      },
      { temp: fullMatch[dataType] }
    ).temp : fullMatch[dataType];
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    serializedBeforeLoadData !== void 0 || serializedLoaderData !== void 0 || (extracted == null ? void 0 : extracted.length) ? /* @__PURE__ */ jsx(
      ScriptOnce,
      {
        children: `__TSR__.matches[${props.matchIndex}] = ${jsesc(
          {
            __beforeLoadContext: router.options.transformer.stringify(
              serializedBeforeLoadData
            ),
            loaderData: router.options.transformer.stringify(serializedLoaderData),
            extracted: extracted ? Object.fromEntries(
              extracted.map((entry) => {
                return [entry.id, pick(entry, ["type", "path"])];
              })
            ) : {}
          },
          {
            isScriptContext: true,
            wrap: true,
            json: true
          }
        )}; __TSR__.initMatch(${props.matchIndex})`
      }
    ) : null,
    extracted ? extracted.map((d, i) => {
      if (d.type === "stream") {
        return /* @__PURE__ */ jsx(DehydrateStream, { entry: d }, d.id);
      }
      return /* @__PURE__ */ jsx(DehydratePromise, { entry: d }, d.id);
    }) : null
  ] });
}
function replaceBy(obj, cb, path = []) {
  if (isPlainArray(obj)) {
    return obj.map((value, i) => replaceBy(value, cb, [...path, `${i}`]));
  }
  if (isPlainObject(obj)) {
    const newObj2 = {};
    for (const key in obj) {
      newObj2[key] = replaceBy(obj[key], cb, [...path, key]);
    }
    return newObj2;
  }
  const newObj = cb(obj, path);
  if (newObj !== obj) {
    return newObj;
  }
  return obj;
}
function DehydratePromise({ entry }) {
  return /* @__PURE__ */ jsx("div", { className: "tsr-once", children: /* @__PURE__ */ jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsx(InnerDehydratePromise, { entry }) }) });
}
function InnerDehydratePromise({ entry }) {
  if (entry.value.status === "pending") {
    throw entry.value;
  }
  return /* @__PURE__ */ jsx(
    ScriptOnce,
    {
      children: `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].resolve(${jsesc(
        entry.value.data,
        {
          isScriptContext: true,
          wrap: true,
          json: true
        }
      )})`
    }
  );
}
function DehydrateStream({ entry }) {
  invariant(entry.streamState, "StreamState should be defined");
  return /* @__PURE__ */ jsx(
    StreamChunks,
    {
      streamState: entry.streamState,
      children: (chunk) => /* @__PURE__ */ jsx(
        ScriptOnce,
        {
          children: chunk ? `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.enqueue(new TextEncoder().encode(${jsesc(
            chunk.toString(),
            {
              isScriptContext: true,
              wrap: true,
              json: true
            }
          )}))` : `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.close()`
        }
      )
    }
  );
}
function createStreamState({
  stream
}) {
  const streamState = {
    promises: []
  };
  const reader = stream.getReader();
  const read = (index) => {
    streamState.promises[index] = createControlledPromise();
    return reader.read().then(({ done, value }) => {
      if (done) {
        streamState.promises[index].resolve(null);
        reader.releaseLock();
        return;
      }
      streamState.promises[index].resolve(value);
      return read(index + 1);
    });
  };
  read(0).catch((err) => {
    console.error("stream read error", err);
  });
  return streamState;
}
function StreamChunks({
  streamState,
  children,
  __index = 0
}) {
  const promise = streamState.promises[__index];
  if (!promise) {
    return null;
  }
  if (promise.status === "pending") {
    throw promise;
  }
  const chunk = promise.value;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    children(chunk),
    /* @__PURE__ */ jsx("div", { className: "tsr-once", children: /* @__PURE__ */ jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsx(
      StreamChunks,
      {
        streamState,
        __index: __index + 1,
        children
      }
    ) }) })
  ] });
}
function deepImmutableSetByPath(obj, path, value) {
  if (path.length === 0) {
    return value;
  }
  const [key, ...rest] = path;
  if (Array.isArray(obj)) {
    return obj.map((item, i) => {
      if (i === Number(key)) {
        return deepImmutableSetByPath(item, rest, value);
      }
      return item;
    });
  }
  if (isPlainObject(obj)) {
    return {
      ...obj,
      [key]: deepImmutableSetByPath(obj[key], rest, value)
    };
  }
  return obj;
}
function deepMutableSetByPath(obj, path, value) {
  if (path.length === 1) {
    obj[path[0]] = value;
  }
  const [key, ...rest] = path;
  if (Array.isArray(obj)) {
    deepMutableSetByPath(obj[Number(key)], rest, value);
  } else if (isPlainObject(obj)) {
    deepMutableSetByPath(obj[key], rest, value);
  }
}
export {
  AfterEachMatch,
  afterHydrate,
  replaceBy,
  serializeLoaderData
};
//# sourceMappingURL=serialization.js.map
