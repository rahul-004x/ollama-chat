import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import * as React from "react";
import { createElement } from "react";
import { useRouter, ScriptOnce, useRouterState } from "@tanstack/react-router";
import { createPortal } from "react-dom";
import jsesc from "jsesc";
import { Context } from "@tanstack/react-cross-context";
import { Asset } from "./Asset.js";
const useMeta = () => {
  const router = useRouter();
  const routeMeta = useRouterState({
    select: (state) => {
      return state.matches.map((match) => match.meta).filter(Boolean);
    }
  });
  const meta = React.useMemo(() => {
    const resultMeta = [];
    const metaByName = {};
    let title;
    [...routeMeta].reverse().forEach((metas) => {
      [...metas].reverse().forEach((m) => {
        if (m.title) {
          if (!title) {
            title = {
              tag: "title",
              children: m.title
            };
          }
        } else {
          if (m.name) {
            if (metaByName[m.name]) {
              return;
            } else {
              metaByName[m.name] = true;
            }
          }
          resultMeta.push({
            tag: "meta",
            attrs: {
              ...m
            }
          });
        }
      });
    });
    if (title) {
      resultMeta.push(title);
    }
    resultMeta.reverse();
    return resultMeta;
  }, [routeMeta]);
  const links = useRouterState({
    select: (state) => state.matches.map((match) => match.links).filter(Boolean).flat(1).map((link) => ({
      tag: "link",
      attrs: {
        ...link
      }
    }))
  });
  const preloadMeta = useRouterState({
    select: (state) => {
      const preloadMeta2 = [];
      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(
        (route) => {
          var _a, _b, _c;
          return (_c = (_b = (_a = router.manifest) == null ? void 0 : _a.routes[route.id]) == null ? void 0 : _b.preloads) == null ? void 0 : _c.filter(Boolean).forEach((preload) => {
            preloadMeta2.push({
              tag: "link",
              attrs: {
                rel: "modulepreload",
                href: preload
              }
            });
          });
        }
      );
      return preloadMeta2;
    }
  });
  return uniqBy(
    [...meta, ...preloadMeta, ...links],
    (d) => {
      return JSON.stringify(d);
    }
  );
};
const useMetaElements = () => {
  const router = useRouter();
  const meta = useMeta();
  const dehydratedCtx = React.useContext(
    Context.get("TanStackRouterHydrationContext", {})
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("meta", { name: "tsr-meta" }),
    meta.map((asset, i) => /* @__PURE__ */ createElement(Asset, { ...asset, key: `tsr-meta-${JSON.stringify(asset)}` })),
    /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(
        ScriptOnce,
        {
          log: false,
          children: `
__TSR__ = {
  matches: [],
  streamedValues: {},
  initMatch: (index) => {
    Object.entries(__TSR__.matches[index].extracted).forEach(([id, ex]) => {
      if (ex.type === 'stream') {
        let controller;
        ex.value = new ReadableStream({
          start(c) { controller = c; }
        })
        ex.value.controller = controller
      } else if (ex.type === 'promise') {
        let r, j
        ex.value = new Promise((r_, j_) => { r = r_, j = j_ })
        ex.resolve = r; ex.reject = j
      }
    })
  },
  cleanScripts: () => {
    document.querySelectorAll('.tsr-once').forEach((el) => {
      el.remove()
    })
  },
}`
        }
      ),
      /* @__PURE__ */ jsx(
        ScriptOnce,
        {
          children: `__TSR__.dehydrated = ${jsesc(
            router.options.transformer.stringify(dehydratedCtx),
            {
              isScriptContext: true,
              wrap: true,
              json: true
            }
          )}`
        }
      )
    ] }),
    /* @__PURE__ */ jsx("meta", { name: "/tsr-meta" })
  ] });
};
const Meta = ({ children }) => {
  const router = useRouter();
  const metaElements = useMetaElements();
  const [mounted, setMounted] = React.useState(false);
  React[typeof document !== "undefined" ? "useLayoutEffect" : "useEffect"](() => {
    if (typeof document === "undefined") {
      return;
    }
    const start = document.head.querySelector('meta[name="tsr-meta"]');
    const end = document.head.querySelector('meta[name="/tsr-meta"]');
    let current = start == null ? void 0 : start.nextElementSibling;
    while (current && current !== end) {
      const next = current.nextElementSibling;
      current.remove();
      current = next;
    }
    start == null ? void 0 : start.remove();
    end == null ? void 0 : end.remove();
    setMounted(true);
  }, []);
  const all = /* @__PURE__ */ jsxs(Fragment, { children: [
    metaElements,
    children
  ] });
  if (router.isServer) {
    return all;
  }
  if (!mounted) {
    return null;
  }
  return createPortal(all, document.head);
};
function Html({ children, ...props }) {
  const router = useRouter();
  if (!router.isServer) {
    return /* @__PURE__ */ jsx(Fragment, { children });
  }
  return /* @__PURE__ */ jsx("html", { children });
}
function Head({ children, ...props }) {
  const router = useRouter();
  if (!router.isServer) {
    return children;
  }
  return /* @__PURE__ */ jsx("head", { children });
}
function Body({ children, ...props }) {
  const router = useRouter();
  if (!router.isServer) {
    return children;
  }
  return /* @__PURE__ */ jsx("body", { children: /* @__PURE__ */ jsx("div", { id: "root", children }) });
}
function uniqBy(arr, fn) {
  const seen = /* @__PURE__ */ new Set();
  return arr.filter((item) => {
    const key = fn(item);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}
export {
  Body,
  Head,
  Html,
  Meta,
  useMeta,
  useMetaElements
};
//# sourceMappingURL=Meta.js.map
