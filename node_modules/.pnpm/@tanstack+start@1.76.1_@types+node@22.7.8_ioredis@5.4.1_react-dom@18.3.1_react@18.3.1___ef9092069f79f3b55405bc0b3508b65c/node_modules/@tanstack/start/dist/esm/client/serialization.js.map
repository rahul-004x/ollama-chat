{"version":3,"file":"serialization.js","sources":["../../../src/client/serialization.tsx"],"sourcesContent":["import * as React from 'react'\nimport {\n  ScriptOnce,\n  createControlledPromise,\n  defer,\n  isPlainArray,\n  isPlainObject,\n  pick,\n  useRouter,\n} from '@tanstack/react-router'\nimport jsesc from 'jsesc'\nimport invariant from 'tiny-invariant'\nimport type {\n  AnyRouteMatch,\n  AnyRouter,\n  ExtractedEntry,\n  StreamState,\n} from '@tanstack/react-router'\n\nexport function serializeLoaderData(\n  dataType: '__beforeLoadContext' | 'loaderData',\n  data: any,\n  ctx: {\n    match: AnyRouteMatch\n    router: AnyRouter\n  },\n) {\n  if (!ctx.router.isServer) {\n    return data\n  }\n\n  ;(ctx.match as any).extracted = (ctx.match as any).extracted || []\n\n  const extracted = (ctx.match as any).extracted\n\n  const replacedLoaderData = replaceBy(data, (value, path) => {\n    const type =\n      value instanceof ReadableStream\n        ? 'stream'\n        : value instanceof Promise\n          ? 'promise'\n          : undefined\n\n    if (type) {\n      const entry: ExtractedEntry = {\n        dataType,\n        type,\n        path,\n        id: extracted.length,\n        value,\n        matchIndex: ctx.match.index,\n      }\n\n      extracted.push(entry)\n\n      // If it's a stream, we need to tee it so we can read it multiple times\n      if (type === 'stream') {\n        const [copy1, copy2] = value.tee()\n        entry.streamState = createStreamState({ stream: copy2 })\n\n        return copy1\n      } else {\n        defer(value)\n      }\n    }\n\n    return value\n  })\n\n  return replacedLoaderData\n}\n\n// Right after hydration and before the first render, we need to rehydrate each match\n// This includes rehydrating the loaderData and also using the beforeLoadContext\n// to reconstruct any context that was serialized on the server\nexport function afterHydrate({ router }: { router: AnyRouter }) {\n  router.state.matches.forEach((match) => {\n    const route = router.looseRoutesById[match.routeId]!\n    const dMatch = window.__TSR__?.matches[match.index]\n    if (dMatch) {\n      const parentMatch = router.state.matches[match.index - 1]\n      const parentContext = parentMatch?.context ?? router.options.context ?? {}\n      if (dMatch.__beforeLoadContext) {\n        match.__beforeLoadContext = router.options.transformer.parse(\n          dMatch.__beforeLoadContext,\n        ) as any\n\n        match.context = {\n          ...parentContext,\n          ...match.context,\n          ...match.__beforeLoadContext,\n        }\n      }\n\n      if (dMatch.loaderData) {\n        match.loaderData = router.options.transformer.parse(dMatch.loaderData)\n      }\n\n      const extracted = dMatch.extracted\n\n      if (extracted) {\n        Object.entries(extracted).forEach(([_, ex]: any) => {\n          if (ex.value instanceof Promise) {\n            const og = ex.value\n            ex.value = og.then((data: any) => {\n              return data\n            })\n          }\n          deepMutableSetByPath(match, ['loaderData', ...ex.path], ex.value)\n        })\n      }\n    }\n\n    const meta =\n      match.status === 'success'\n        ? route.options.meta?.({\n            matches: router.state.matches,\n            match,\n            params: match.params,\n            loaderData: match.loaderData,\n          })\n        : undefined\n\n    Object.assign(match, {\n      meta,\n      links: route.options.links?.(),\n      scripts: route.options.scripts?.(),\n    })\n  })\n}\n\nexport function AfterEachMatch(props: { match: any; matchIndex: number }) {\n  const router = useRouter()\n\n  const fullMatch = router.state.matches[props.matchIndex]!\n\n  if (!router.isServer) {\n    return null\n  }\n\n  const extracted = (fullMatch as any).extracted as\n    | undefined\n    | Array<ExtractedEntry>\n\n  const [serializedBeforeLoadData, serializedLoaderData] = (\n    ['__beforeLoadContext', 'loaderData'] as const\n  ).map((dataType) => {\n    return extracted\n      ? extracted.reduce(\n          (acc: any, entry: ExtractedEntry) => {\n            if (entry.dataType !== dataType) {\n              return deepImmutableSetByPath(\n                acc,\n                ['temp', ...entry.path],\n                undefined,\n              )\n            }\n            return acc\n          },\n          { temp: fullMatch[dataType] },\n        ).temp\n      : fullMatch[dataType]\n  })\n\n  return (\n    <>\n      {serializedBeforeLoadData !== undefined ||\n      serializedLoaderData !== undefined ||\n      extracted?.length ? (\n        <ScriptOnce\n          children={`__TSR__.matches[${props.matchIndex}] = ${jsesc(\n            {\n              __beforeLoadContext: router.options.transformer.stringify(\n                serializedBeforeLoadData,\n              ),\n              loaderData:\n                router.options.transformer.stringify(serializedLoaderData),\n              extracted: extracted\n                ? Object.fromEntries(\n                    extracted.map((entry) => {\n                      return [entry.id, pick(entry, ['type', 'path'])]\n                    }),\n                  )\n                : {},\n            },\n            {\n              isScriptContext: true,\n              wrap: true,\n              json: true,\n            },\n          )}; __TSR__.initMatch(${props.matchIndex})`}\n        />\n      ) : null}\n      {extracted\n        ? extracted.map((d, i) => {\n            if (d.type === 'stream') {\n              return <DehydrateStream key={d.id} entry={d} />\n            }\n\n            return <DehydratePromise key={d.id} entry={d} />\n          })\n        : null}\n    </>\n  )\n}\n\nexport function replaceBy<T>(\n  obj: T,\n  cb: (value: any, path: Array<string>) => any,\n  path: Array<string> = [],\n): T {\n  if (isPlainArray(obj)) {\n    return obj.map((value, i) => replaceBy(value, cb, [...path, `${i}`])) as any\n  }\n\n  if (isPlainObject(obj)) {\n    // Do not allow objects with illegal\n    const newObj: any = {}\n\n    for (const key in obj) {\n      newObj[key] = replaceBy(obj[key], cb, [...path, key])\n    }\n\n    return newObj\n  }\n\n  // // Detect classes, functions, and other non-serializable objects\n  // // and return undefined. Exclude some known types that are serializable\n  // if (\n  //   typeof obj === 'function' ||\n  //   (typeof obj === 'object' &&\n  //     ![Object, Promise, ReadableStream].includes((obj as any)?.constructor))\n  // ) {\n  //   console.info(obj)\n  //   warning(false, `Non-serializable value ☝️ found at ${path.join('.')}`)\n  //   return undefined as any\n  // }\n\n  const newObj = cb(obj, path)\n\n  if (newObj !== obj) {\n    return newObj\n  }\n\n  return obj\n}\n\nfunction DehydratePromise({ entry }: { entry: ExtractedEntry }) {\n  return (\n    <div className=\"tsr-once\">\n      <React.Suspense fallback={null}>\n        <InnerDehydratePromise entry={entry} />\n      </React.Suspense>\n    </div>\n  )\n}\n\nfunction InnerDehydratePromise({ entry }: { entry: ExtractedEntry }) {\n  if (entry.value.status === 'pending') {\n    throw entry.value\n  }\n\n  return (\n    <ScriptOnce\n      children={`__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].resolve(${jsesc(\n        entry.value.data,\n        {\n          isScriptContext: true,\n          wrap: true,\n          json: true,\n        },\n      )})`}\n    />\n  )\n}\n\nfunction DehydrateStream({ entry }: { entry: ExtractedEntry }) {\n  invariant(entry.streamState, 'StreamState should be defined')\n\n  return (\n    <StreamChunks\n      streamState={entry.streamState}\n      children={(chunk) => (\n        <ScriptOnce\n          children={\n            chunk\n              ? `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.enqueue(new TextEncoder().encode(${jsesc(\n                  chunk.toString(),\n                  {\n                    isScriptContext: true,\n                    wrap: true,\n                    json: true,\n                  },\n                )}))`\n              : `__TSR__.matches[${entry.matchIndex}].extracted[${entry.id}].value.controller.close()`\n          }\n        />\n      )}\n    />\n  )\n}\n\n// Readable stream with state is a stream that has a promise that resolves to the next chunk\nfunction createStreamState({\n  stream,\n}: {\n  stream: ReadableStream\n}): StreamState {\n  const streamState: StreamState = {\n    promises: [],\n  }\n\n  const reader = stream.getReader()\n\n  const read = (index: number): any => {\n    streamState.promises[index] = createControlledPromise()\n\n    return reader.read().then(({ done, value }) => {\n      if (done) {\n        streamState.promises[index]!.resolve(null)\n        reader.releaseLock()\n        return\n      }\n\n      streamState.promises[index]!.resolve(value)\n\n      return read(index + 1)\n    })\n  }\n\n  read(0).catch((err: any) => {\n    console.error('stream read error', err)\n  })\n\n  return streamState\n}\n\nfunction StreamChunks({\n  streamState,\n  children,\n  __index = 0,\n}: {\n  streamState: StreamState\n  children: (chunk: string | null) => JSX.Element\n  __index?: number\n}) {\n  const promise = streamState.promises[__index]\n\n  if (!promise) {\n    return null\n  }\n\n  if (promise.status === 'pending') {\n    throw promise\n  }\n\n  const chunk = promise.value!\n\n  return (\n    <>\n      {children(chunk)}\n      <div className=\"tsr-once\">\n        <React.Suspense fallback={null}>\n          <StreamChunks\n            streamState={streamState}\n            __index={__index + 1}\n            children={children}\n          />\n        </React.Suspense>\n      </div>\n    </>\n  )\n}\n\nfunction deepImmutableSetByPath<T>(obj: T, path: Array<string>, value: any): T {\n  // immutable set by path retaining array and object references\n  if (path.length === 0) {\n    return value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    return obj.map((item, i) => {\n      if (i === Number(key)) {\n        return deepImmutableSetByPath(item, rest, value)\n      }\n      return item\n    }) as T\n  }\n\n  if (isPlainObject(obj)) {\n    return {\n      ...obj,\n      [key!]: deepImmutableSetByPath((obj as any)[key!], rest, value),\n    }\n  }\n\n  return obj\n}\n\nfunction deepMutableSetByPath<T>(obj: T, path: Array<string>, value: any) {\n  // mutable set by path retaining array and object references\n  if (path.length === 1) {\n    ;(obj as any)[path[0]!] = value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    deepMutableSetByPath(obj[Number(key)], rest, value)\n  } else if (isPlainObject(obj)) {\n    deepMutableSetByPath((obj as any)[key!], rest, value)\n  }\n}\n"],"names":["newObj"],"mappings":";;;;;AAmBgB,SAAA,oBACd,UACA,MACA,KAIA;AACI,MAAA,CAAC,IAAI,OAAO,UAAU;AACjB,WAAA;AAAA,EACT;AAEE,MAAI,MAAc,YAAa,IAAI,MAAc,aAAa;AAE1D,QAAA,YAAa,IAAI,MAAc;AAErC,QAAM,qBAAqB,UAAU,MAAM,CAAC,OAAO,SAAS;AAC1D,UAAM,OACJ,iBAAiB,iBACb,WACA,iBAAiB,UACf,YACA;AAER,QAAI,MAAM;AACR,YAAM,QAAwB;AAAA,QAC5B;AAAA,QACA;AAAA,QACA;AAAA,QACA,IAAI,UAAU;AAAA,QACd;AAAA,QACA,YAAY,IAAI,MAAM;AAAA,MAAA;AAGxB,gBAAU,KAAK,KAAK;AAGpB,UAAI,SAAS,UAAU;AACrB,cAAM,CAAC,OAAO,KAAK,IAAI,MAAM,IAAI;AACjC,cAAM,cAAc,kBAAkB,EAAE,QAAQ,MAAO,CAAA;AAEhD,eAAA;AAAA,MAAA,OACF;AACL,cAAM,KAAK;AAAA,MACb;AAAA,IACF;AAEO,WAAA;AAAA,EAAA,CACR;AAEM,SAAA;AACT;AAKgB,SAAA,aAAa,EAAE,UAAiC;AAC9D,SAAO,MAAM,QAAQ,QAAQ,CAAC,UAAU;;AACtC,UAAM,QAAQ,OAAO,gBAAgB,MAAM,OAAO;AAClD,UAAM,UAAS,YAAO,YAAP,mBAAgB,QAAQ,MAAM;AAC7C,QAAI,QAAQ;AACV,YAAM,cAAc,OAAO,MAAM,QAAQ,MAAM,QAAQ,CAAC;AACxD,YAAM,iBAAgB,2CAAa,YAAW,OAAO,QAAQ,WAAW;AACxE,UAAI,OAAO,qBAAqB;AACxB,cAAA,sBAAsB,OAAO,QAAQ,YAAY;AAAA,UACrD,OAAO;AAAA,QAAA;AAGT,cAAM,UAAU;AAAA,UACd,GAAG;AAAA,UACH,GAAG,MAAM;AAAA,UACT,GAAG,MAAM;AAAA,QAAA;AAAA,MAEb;AAEA,UAAI,OAAO,YAAY;AACrB,cAAM,aAAa,OAAO,QAAQ,YAAY,MAAM,OAAO,UAAU;AAAA,MACvE;AAEA,YAAM,YAAY,OAAO;AAEzB,UAAI,WAAW;AACN,eAAA,QAAQ,SAAS,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE,MAAW;AAC9C,cAAA,GAAG,iBAAiB,SAAS;AAC/B,kBAAM,KAAK,GAAG;AACd,eAAG,QAAQ,GAAG,KAAK,CAAC,SAAc;AACzB,qBAAA;AAAA,YAAA,CACR;AAAA,UACH;AACqB,+BAAA,OAAO,CAAC,cAAc,GAAG,GAAG,IAAI,GAAG,GAAG,KAAK;AAAA,QAAA,CACjE;AAAA,MACH;AAAA,IACF;AAEA,UAAM,OACJ,MAAM,WAAW,aACb,iBAAM,SAAQ,SAAd,4BAAqB;AAAA,MACnB,SAAS,OAAO,MAAM;AAAA,MACtB;AAAA,MACA,QAAQ,MAAM;AAAA,MACd,YAAY,MAAM;AAAA,IAAA,KAEpB;AAEN,WAAO,OAAO,OAAO;AAAA,MACnB;AAAA,MACA,QAAO,iBAAM,SAAQ,UAAd;AAAA,MACP,UAAS,iBAAM,SAAQ,YAAd;AAAA,IAAwB,CAClC;AAAA,EAAA,CACF;AACH;AAEO,SAAS,eAAe,OAA2C;AACxE,QAAM,SAAS;AAEf,QAAM,YAAY,OAAO,MAAM,QAAQ,MAAM,UAAU;AAEnD,MAAA,CAAC,OAAO,UAAU;AACb,WAAA;AAAA,EACT;AAEA,QAAM,YAAa,UAAkB;AAI/B,QAAA,CAAC,0BAA0B,oBAAoB,IACnD,CAAC,uBAAuB,YAAY,EACpC,IAAI,CAAC,aAAa;AAClB,WAAO,YACH,UAAU;AAAA,MACR,CAAC,KAAU,UAA0B;AAC/B,YAAA,MAAM,aAAa,UAAU;AACxB,iBAAA;AAAA,YACL;AAAA,YACA,CAAC,QAAQ,GAAG,MAAM,IAAI;AAAA,YACtB;AAAA,UAAA;AAAA,QAEJ;AACO,eAAA;AAAA,MACT;AAAA,MACA,EAAE,MAAM,UAAU,QAAQ,EAAE;AAAA,IAAA,EAC5B,OACF,UAAU,QAAQ;AAAA,EAAA,CACvB;AAED,SAEK,qBAAA,UAAA,EAAA,UAAA;AAAA,IAAA,6BAA6B,UAC9B,yBAAyB,WACzB,uCAAW,UACT;AAAA,MAAC;AAAA,MAAA;AAAA,QACC,UAAU,mBAAmB,MAAM,UAAU,OAAO;AAAA,UAClD;AAAA,YACE,qBAAqB,OAAO,QAAQ,YAAY;AAAA,cAC9C;AAAA,YACF;AAAA,YACA,YACE,OAAO,QAAQ,YAAY,UAAU,oBAAoB;AAAA,YAC3D,WAAW,YACP,OAAO;AAAA,cACL,UAAU,IAAI,CAAC,UAAU;AAChB,uBAAA,CAAC,MAAM,IAAI,KAAK,OAAO,CAAC,QAAQ,MAAM,CAAC,CAAC;AAAA,cAAA,CAChD;AAAA,YAAA,IAEH,CAAC;AAAA,UACP;AAAA,UACA;AAAA,YACE,iBAAiB;AAAA,YACjB,MAAM;AAAA,YACN,MAAM;AAAA,UACR;AAAA,QACD,CAAA,uBAAuB,MAAM,UAAU;AAAA,MAAA;AAAA,IAAA,IAExC;AAAA,IACH,YACG,UAAU,IAAI,CAAC,GAAG,MAAM;AAClB,UAAA,EAAE,SAAS,UAAU;AACvB,eAAQ,oBAAA,iBAAA,EAA2B,OAAO,KAAb,EAAE,EAAc;AAAA,MAC/C;AAEA,aAAQ,oBAAA,kBAAA,EAA4B,OAAO,KAAb,EAAE,EAAc;AAAA,IAC/C,CAAA,IACD;AAAA,EACN,EAAA,CAAA;AAEJ;AAEO,SAAS,UACd,KACA,IACA,OAAsB,CAAA,GACnB;AACC,MAAA,aAAa,GAAG,GAAG;AACrB,WAAO,IAAI,IAAI,CAAC,OAAO,MAAM,UAAU,OAAO,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;AAAA,EACtE;AAEI,MAAA,cAAc,GAAG,GAAG;AAEtB,UAAMA,UAAc,CAAA;AAEpB,eAAW,OAAO,KAAK;AACrBA,cAAO,GAAG,IAAI,UAAU,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC;AAAA,IACtD;AAEOA,WAAAA;AAAAA,EACT;AAcM,QAAA,SAAS,GAAG,KAAK,IAAI;AAE3B,MAAI,WAAW,KAAK;AACX,WAAA;AAAA,EACT;AAEO,SAAA;AACT;AAEA,SAAS,iBAAiB,EAAE,SAAoC;AAC9D,SACG,oBAAA,OAAA,EAAI,WAAU,YACb,8BAAC,MAAM,UAAN,EAAe,UAAU,MACxB,UAAA,oBAAC,uBAAsB,EAAA,MAAc,CAAA,GACvC,EACF,CAAA;AAEJ;AAEA,SAAS,sBAAsB,EAAE,SAAoC;AAC/D,MAAA,MAAM,MAAM,WAAW,WAAW;AACpC,UAAM,MAAM;AAAA,EACd;AAGE,SAAA;AAAA,IAAC;AAAA,IAAA;AAAA,MACC,UAAU,mBAAmB,MAAM,UAAU,eAAe,MAAM,EAAE,aAAa;AAAA,QAC/E,MAAM,MAAM;AAAA,QACZ;AAAA,UACE,iBAAiB;AAAA,UACjB,MAAM;AAAA,UACN,MAAM;AAAA,QACR;AAAA,MACD,CAAA;AAAA,IAAA;AAAA,EAAA;AAGP;AAEA,SAAS,gBAAgB,EAAE,SAAoC;AACnD,YAAA,MAAM,aAAa,+BAA+B;AAG1D,SAAA;AAAA,IAAC;AAAA,IAAA;AAAA,MACC,aAAa,MAAM;AAAA,MACnB,UAAU,CAAC,UACT;AAAA,QAAC;AAAA,QAAA;AAAA,UACC,UACE,QACI,mBAAmB,MAAM,UAAU,eAAe,MAAM,EAAE,uDAAuD;AAAA,YAC/G,MAAM,SAAS;AAAA,YACf;AAAA,cACE,iBAAiB;AAAA,cACjB,MAAM;AAAA,cACN,MAAM;AAAA,YACR;AAAA,UAAA,CACD,OACD,mBAAmB,MAAM,UAAU,eAAe,MAAM,EAAE;AAAA,QAAA;AAAA,MAElE;AAAA,IAAA;AAAA,EAAA;AAIR;AAGA,SAAS,kBAAkB;AAAA,EACzB;AACF,GAEgB;AACd,QAAM,cAA2B;AAAA,IAC/B,UAAU,CAAC;AAAA,EAAA;AAGP,QAAA,SAAS,OAAO;AAEhB,QAAA,OAAO,CAAC,UAAuB;AACvB,gBAAA,SAAS,KAAK,IAAI,wBAAwB;AAE/C,WAAA,OAAO,OAAO,KAAK,CAAC,EAAE,MAAM,YAAY;AAC7C,UAAI,MAAM;AACR,oBAAY,SAAS,KAAK,EAAG,QAAQ,IAAI;AACzC,eAAO,YAAY;AACnB;AAAA,MACF;AAEA,kBAAY,SAAS,KAAK,EAAG,QAAQ,KAAK;AAEnC,aAAA,KAAK,QAAQ,CAAC;AAAA,IAAA,CACtB;AAAA,EAAA;AAGH,OAAK,CAAC,EAAE,MAAM,CAAC,QAAa;AAClB,YAAA,MAAM,qBAAqB,GAAG;AAAA,EAAA,CACvC;AAEM,SAAA;AACT;AAEA,SAAS,aAAa;AAAA,EACpB;AAAA,EACA;AAAA,EACA,UAAU;AACZ,GAIG;AACK,QAAA,UAAU,YAAY,SAAS,OAAO;AAE5C,MAAI,CAAC,SAAS;AACL,WAAA;AAAA,EACT;AAEI,MAAA,QAAQ,WAAW,WAAW;AAC1B,UAAA;AAAA,EACR;AAEA,QAAM,QAAQ,QAAQ;AAEtB,SAEK,qBAAA,UAAA,EAAA,UAAA;AAAA,IAAA,SAAS,KAAK;AAAA,IACf,oBAAC,SAAI,WAAU,YACb,8BAAC,MAAM,UAAN,EAAe,UAAU,MACxB,UAAA;AAAA,MAAC;AAAA,MAAA;AAAA,QACC;AAAA,QACA,SAAS,UAAU;AAAA,QACnB;AAAA,MAAA;AAAA,OAEJ,EACF,CAAA;AAAA,EACF,EAAA,CAAA;AAEJ;AAEA,SAAS,uBAA0B,KAAQ,MAAqB,OAAe;AAEzE,MAAA,KAAK,WAAW,GAAG;AACd,WAAA;AAAA,EACT;AAEA,QAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AAEnB,MAAA,MAAM,QAAQ,GAAG,GAAG;AACtB,WAAO,IAAI,IAAI,CAAC,MAAM,MAAM;AACtB,UAAA,MAAM,OAAO,GAAG,GAAG;AACd,eAAA,uBAAuB,MAAM,MAAM,KAAK;AAAA,MACjD;AACO,aAAA;AAAA,IAAA,CACR;AAAA,EACH;AAEI,MAAA,cAAc,GAAG,GAAG;AACf,WAAA;AAAA,MACL,GAAG;AAAA,MACH,CAAC,GAAI,GAAG,uBAAwB,IAAY,GAAI,GAAG,MAAM,KAAK;AAAA,IAAA;AAAA,EAElE;AAEO,SAAA;AACT;AAEA,SAAS,qBAAwB,KAAQ,MAAqB,OAAY;AAEpE,MAAA,KAAK,WAAW,GAAG;AACnB,QAAY,KAAK,CAAC,CAAE,IAAI;AAAA,EAC5B;AAEA,QAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AAEnB,MAAA,MAAM,QAAQ,GAAG,GAAG;AACtB,yBAAqB,IAAI,OAAO,GAAG,CAAC,GAAG,MAAM,KAAK;AAAA,EAAA,WACzC,cAAc,GAAG,GAAG;AAC7B,yBAAsB,IAAY,GAAI,GAAG,MAAM,KAAK;AAAA,EACtD;AACF;"}