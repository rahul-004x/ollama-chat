import { defaultParseSearch, isRedirect, isNotFound } from "@tanstack/react-router";
import invariant from "tiny-invariant";
import { eventHandler, toWebRequest, getResponseStatus, getEvent } from "vinxi/http";
import { getManifest } from "vinxi/manifest";
import { serverFnPayloadTypeHeader, serverFnReturnTypeHeader } from "../constants.js";
const index = eventHandler(handleServerAction);
async function handleServerAction(event) {
  return handleServerRequest(toWebRequest(event));
}
async function handleServerRequest(request, event) {
  var _a, _b;
  const method = request.method;
  const url = new URL(request.url, "http://localhost:3000");
  const search = Object.fromEntries(
    new URLSearchParams(url.search).entries()
  );
  const serverFnId = search._serverFnId;
  const serverFnName = search._serverFnName;
  if (!serverFnId || !serverFnName) {
    throw new Error("Invalid request");
  }
  invariant(typeof serverFnId === "string", "Invalid server action");
  if (process.env.NODE_ENV === "development")
    console.info(`ServerFn Request: ${serverFnId} - ${serverFnName}`);
  if (process.env.NODE_ENV === "development") console.info();
  const action = (_b = await ((_a = getManifest("server").chunks[serverFnId]) == null ? void 0 : _a.import())) == null ? void 0 : _b[serverFnName];
  const response = await (async () => {
    try {
      const args = await (async () => {
        var _a2;
        if (request.headers.get(serverFnPayloadTypeHeader) === "payload") {
          return [
            method.toLowerCase() === "get" ? (() => {
              var _a3;
              return (_a3 = defaultParseSearch(url.search)) == null ? void 0 : _a3.payload;
            })() : await request.json(),
            { method, request }
          ];
        }
        if (request.headers.get(serverFnPayloadTypeHeader) === "formData" || ((_a2 = request.headers.get("Content-Type")) == null ? void 0 : _a2.includes("multipart/form-data"))) {
          return [
            method.toLowerCase() === "get" ? (() => {
              const { _serverFnId, _serverFnName, payload } = search;
              return payload;
            })() : await request.formData(),
            { method, request }
          ];
        }
        if (request.headers.get(serverFnPayloadTypeHeader) === "request") {
          return [request, { method, request }];
        }
        return await request.json();
      })();
      const result = await action(...args);
      if (result instanceof Response) {
        return result;
      }
      if (isRedirect(result) || isNotFound(result)) {
        return redirectOrNotFoundResponse(result);
      }
      return new Response(
        result !== void 0 ? JSON.stringify(result) : void 0,
        {
          status: getResponseStatus(getEvent()),
          headers: {
            "Content-Type": "application/json",
            [serverFnReturnTypeHeader]: "json"
          }
        }
      );
    } catch (error) {
      if (error instanceof Response) {
        return error;
      }
      if (isRedirect(error) || isNotFound(error)) {
        return redirectOrNotFoundResponse(error);
      }
      console.error("Server Fn Error!");
      console.error(error);
      console.info();
      return new Response(JSON.stringify(error), {
        status: 500,
        headers: {
          "Content-Type": "application/json",
          [serverFnReturnTypeHeader]: "error"
        }
      });
    }
  })();
  if (process.env.NODE_ENV === "development")
    console.info(`ServerFn Response: ${response.status}`);
  if (response.headers.get("Content-Type") === "application/json") {
    const cloned = response.clone();
    const text = await cloned.text();
    const payload = text ? JSON.stringify(JSON.parse(text)) : "undefined";
    if (process.env.NODE_ENV === "development")
      console.info(
        ` - Payload: ${payload.length > 100 ? payload.substring(0, 100) + "..." : payload}`
      );
  }
  if (process.env.NODE_ENV === "development") console.info();
  return response;
}
function redirectOrNotFoundResponse(error) {
  const { headers, ...rest } = error;
  return new Response(JSON.stringify(rest), {
    status: 200,
    headers: {
      "Content-Type": "application/json",
      [serverFnReturnTypeHeader]: "json",
      ...error.headers || {}
    }
  });
}
export {
  index as default,
  handleServerRequest
};
//# sourceMappingURL=index.js.map
