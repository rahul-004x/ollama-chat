{"version":3,"file":"createStartHandler.js","sources":["../../../src/server/createStartHandler.ts"],"sourcesContent":["import { eventHandler, getResponseHeaders, toWebRequest } from 'vinxi/http'\nimport { createMemoryHistory } from '@tanstack/react-router'\nimport { serializeLoaderData } from '../client/serialization'\nimport { mergeHeaders } from '../client/headers'\nimport {\n  serverFnPayloadTypeHeader,\n  serverFnReturnTypeHeader,\n} from '../constants'\nimport type { EventHandler, EventHandlerRequest, H3Event } from 'vinxi/http'\nimport type { AnyRouter, Manifest } from '@tanstack/react-router'\nimport type { HandlerCallback } from './defaultStreamHandler'\n\nexport type CustomizeStartHandler<TRouter extends AnyRouter> = (\n  cb: HandlerCallback<TRouter>,\n) => EventHandler\n\nexport function createStartHandler<TRouter extends AnyRouter>({\n  createRouter,\n  getRouterManifest,\n}: {\n  createRouter: () => TRouter\n  getRouterManifest?: () => Manifest\n}): CustomizeStartHandler<TRouter> {\n  return (cb) => {\n    return eventHandler(async (event) => {\n      const request = toWebRequest(event)\n\n      const url = new URL(request.url)\n      const href = url.href.replace(url.origin, '')\n\n      // Create a history for the router\n      const history = createMemoryHistory({\n        initialEntries: [href],\n      })\n\n      const router = createRouter()\n\n      // Inject a few of the SSR helpers and defaults\n      router.serializeLoaderData = serializeLoaderData as any\n\n      if (getRouterManifest) {\n        router.manifest = getRouterManifest()\n      }\n\n      // Update the router with the history and context\n      router.update({\n        history,\n      })\n\n      await router.load()\n\n      const responseHeaders = getRequestHeaders({\n        event,\n        router,\n      })\n\n      const response = await cb({\n        request,\n        router,\n        responseHeaders,\n      })\n\n      return response\n    })\n  }\n}\n\nfunction getRequestHeaders(opts: {\n  event: H3Event<EventHandlerRequest>\n  router: AnyRouter\n}): Headers {\n  ;(opts.event as any).__tsrHeadersSent = true\n\n  let headers = mergeHeaders(\n    getResponseHeaders(opts.event),\n    {\n      'Content-Type': 'text/html; charset=UTF-8',\n    },\n    ...opts.router.state.matches.map((match) => {\n      return match.headers\n    }),\n  )\n\n  // Handle Redirects\n  const { redirect } = opts.router.state\n\n  if (redirect) {\n    headers = mergeHeaders(headers, redirect.headers, {\n      Location: redirect.href,\n    })\n  }\n\n  // Remove server function headers\n  ;[serverFnReturnTypeHeader, serverFnPayloadTypeHeader].forEach((header) => {\n    headers.delete(header)\n  })\n\n  return headers\n}\n"],"names":[],"mappings":";;;;;AAgBO,SAAS,mBAA8C;AAAA,EAC5D;AAAA,EACA;AACF,GAGmC;AACjC,SAAO,CAAC,OAAO;AACN,WAAA,aAAa,OAAO,UAAU;AAC7B,YAAA,UAAU,aAAa,KAAK;AAElC,YAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,YAAM,OAAO,IAAI,KAAK,QAAQ,IAAI,QAAQ,EAAE;AAG5C,YAAM,UAAU,oBAAoB;AAAA,QAClC,gBAAgB,CAAC,IAAI;AAAA,MAAA,CACtB;AAED,YAAM,SAAS;AAGf,aAAO,sBAAsB;AAE7B,UAAI,mBAAmB;AACrB,eAAO,WAAW;MACpB;AAGA,aAAO,OAAO;AAAA,QACZ;AAAA,MAAA,CACD;AAED,YAAM,OAAO;AAEb,YAAM,kBAAkB,kBAAkB;AAAA,QACxC;AAAA,QACA;AAAA,MAAA,CACD;AAEK,YAAA,WAAW,MAAM,GAAG;AAAA,QACxB;AAAA,QACA;AAAA,QACA;AAAA,MAAA,CACD;AAEM,aAAA;AAAA,IAAA,CACR;AAAA,EAAA;AAEL;AAEA,SAAS,kBAAkB,MAGf;AACR,OAAK,MAAc,mBAAmB;AAExC,MAAI,UAAU;AAAA,IACZ,mBAAmB,KAAK,KAAK;AAAA,IAC7B;AAAA,MACE,gBAAgB;AAAA,IAClB;AAAA,IACA,GAAG,KAAK,OAAO,MAAM,QAAQ,IAAI,CAAC,UAAU;AAC1C,aAAO,MAAM;AAAA,IAAA,CACd;AAAA,EAAA;AAIH,QAAM,EAAE,SAAa,IAAA,KAAK,OAAO;AAEjC,MAAI,UAAU;AACF,cAAA,aAAa,SAAS,SAAS,SAAS;AAAA,MAChD,UAAU,SAAS;AAAA,IAAA,CACpB;AAAA,EACH;AAGC,GAAC,0BAA0B,yBAAyB,EAAE,QAAQ,CAAC,WAAW;AACzE,YAAQ,OAAO,MAAM;AAAA,EAAA,CACtB;AAEM,SAAA;AACT;"}