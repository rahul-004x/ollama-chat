"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const babel = require("@babel/core");
const t = require("@babel/types");
const _generate = require("@babel/generator");
const babelDeadCodeElimination = require("babel-dead-code-elimination");
const ast = require("./ast.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const babel__namespace = /* @__PURE__ */ _interopNamespaceDefault(babel);
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
let generate = _generate["default"];
if (!generate) {
  generate = _generate;
}
function compileEliminateDeadCode(opts) {
  const ast$1 = ast.parseAst(opts);
  if (!ast$1) {
    throw new Error(
      `Failed to compile ast for compileEliminateDeadCode() for the file: ${opts.filename}`
    );
  }
  babelDeadCodeElimination.deadCodeElimination(ast$1);
  return generate(ast$1, {
    sourceMaps: true
  });
}
function compileCreateServerFnOutput(opts) {
  const ast$1 = ast.parseAst(opts);
  if (!ast$1) {
    throw new Error(
      `Failed to compile ast for compileCreateServerFnOutput() for the file: ${opts.filename}`
    );
  }
  babel__namespace.traverse(ast$1, {
    Program: {
      enter(programPath) {
        let identifierType = "ImportSpecifier";
        let namespaceId = "";
        let serverFnId = "createServerFn";
        programPath.traverse({
          ImportDeclaration: (path) => {
            if (path.node.source.value !== "@tanstack/start") {
              return;
            }
            path.node.specifiers.forEach((specifier) => {
              if (specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier") {
                if (specifier.imported.name === "createServerFn") {
                  serverFnId = specifier.local.name;
                  identifierType = "ImportSpecifier";
                }
              }
              if (specifier.type === "ImportNamespaceSpecifier") {
                identifierType = "ImportNamespaceSpecifier";
                namespaceId = specifier.local.name;
                serverFnId = `${namespaceId}.createServerFn`;
              }
            });
          },
          CallExpression: (path) => {
            const importSpecifierCondition = path.node.callee.type === "Identifier" && path.node.callee.name === serverFnId;
            const importNamespaceSpecifierCondition = path.node.callee.type === "MemberExpression" && path.node.callee.property.type === "Identifier" && path.node.callee.property.name === "createServerFn";
            const createServerFnEntryCondition = identifierType === "ImportSpecifier" ? importSpecifierCondition : importNamespaceSpecifierCondition;
            if (createServerFnEntryCondition) {
              const fn = path.node.arguments[1];
              if (t__namespace.isFunctionExpression(fn) || t__namespace.isArrowFunctionExpression(fn)) {
                if (t__namespace.isBlockStatement(fn.body)) {
                  const hasUseServerDirective = fn.body.directives.some(
                    (directive) => {
                      return directive.value.value === "use server";
                    }
                  );
                  if (!hasUseServerDirective) {
                    fn.body.directives.unshift(
                      t__namespace.directive(t__namespace.directiveLiteral("use server"))
                    );
                  }
                }
              } else if (t__namespace.isIdentifier(fn) || t__namespace.isCallExpression(fn)) {
                const args = t__namespace.restElement(t__namespace.identifier("args"));
                args.typeAnnotation = t__namespace.tsTypeAnnotation(
                  t__namespace.tsTypeReference(
                    t__namespace.identifier("Parameters"),
                    t__namespace.tsTypeParameterInstantiation([
                      t__namespace.tsIndexedAccessType(
                        t__namespace.tsTypeReference(
                          t__namespace.identifier("Parameters"),
                          t__namespace.tsTypeParameterInstantiation([
                            t__namespace.tsTypeQuery(t__namespace.identifier(serverFnId))
                          ])
                        ),
                        t__namespace.tsLiteralType(t__namespace.numericLiteral(1))
                      )
                    ])
                  )
                );
                const wrappedFn = t__namespace.arrowFunctionExpression(
                  [args],
                  t__namespace.blockStatement(
                    [
                      t__namespace.returnStatement(
                        t__namespace.callExpression(
                          t__namespace.memberExpression(fn, t__namespace.identifier("apply")),
                          [t__namespace.identifier("this"), t__namespace.identifier("args")]
                        )
                      )
                    ],
                    [t__namespace.directive(t__namespace.directiveLiteral("use server"))]
                  )
                );
                path.node.arguments[1] = wrappedFn;
              }
            }
          }
        });
      }
    }
  });
  return generate(ast$1, {
    sourceMaps: true,
    minified: process.env.NODE_ENV === "production"
  });
}
exports.compileCreateServerFnOutput = compileCreateServerFnOutput;
exports.compileEliminateDeadCode = compileEliminateDeadCode;
//# sourceMappingURL=compilers.cjs.map
