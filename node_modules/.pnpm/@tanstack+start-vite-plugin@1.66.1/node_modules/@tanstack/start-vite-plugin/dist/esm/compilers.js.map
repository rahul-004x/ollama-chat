{"version":3,"file":"compilers.js","sources":["../../src/compilers.ts"],"sourcesContent":["import * as babel from '@babel/core'\nimport * as t from '@babel/types'\nimport _generate from '@babel/generator'\nimport { deadCodeElimination } from 'babel-dead-code-elimination'\n\nimport { parseAst } from './ast'\nimport type { ParseAstOptions } from './ast'\n\n// Babel is a CJS package and uses `default` as named binding (`exports.default =`).\n// https://github.com/babel/babel/issues/15269.\nlet generate = (_generate as any)['default'] as typeof _generate\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nif (!generate) {\n  generate = _generate\n}\n\nexport function compileEliminateDeadCode(opts: ParseAstOptions) {\n  const ast = parseAst(opts)\n  if (!ast) {\n    throw new Error(\n      `Failed to compile ast for compileEliminateDeadCode() for the file: ${opts.filename}`,\n    )\n  }\n  deadCodeElimination(ast)\n\n  return generate(ast, {\n    sourceMaps: true,\n  })\n}\n\nexport function compileCreateServerFnOutput(opts: ParseAstOptions) {\n  const ast = parseAst(opts)\n\n  if (!ast) {\n    throw new Error(\n      `Failed to compile ast for compileCreateServerFnOutput() for the file: ${opts.filename}`,\n    )\n  }\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath) {\n        let identifierType: 'ImportSpecifier' | 'ImportNamespaceSpecifier' =\n          'ImportSpecifier'\n\n        let namespaceId = ''\n        let serverFnId = 'createServerFn'\n\n        programPath.traverse({\n          ImportDeclaration: (path) => {\n            if (path.node.source.value !== '@tanstack/start') {\n              return\n            }\n\n            path.node.specifiers.forEach((specifier) => {\n              // handles a destructured import being renamed like \"import { createServerFn as myCreateServerFn } from '@tanstack/start';\"\n              if (\n                specifier.type === 'ImportSpecifier' &&\n                specifier.imported.type === 'Identifier'\n              ) {\n                if (specifier.imported.name === 'createServerFn') {\n                  serverFnId = specifier.local.name\n                  identifierType = 'ImportSpecifier'\n                }\n              }\n\n              // handles a namespace import like \"import * as TanStackStart from '@tanstack/start';\"\n              if (specifier.type === 'ImportNamespaceSpecifier') {\n                identifierType = 'ImportNamespaceSpecifier'\n                namespaceId = specifier.local.name\n                serverFnId = `${namespaceId}.createServerFn`\n              }\n            })\n          },\n          CallExpression: (path) => {\n            const importSpecifierCondition =\n              path.node.callee.type === 'Identifier' &&\n              path.node.callee.name === serverFnId\n\n            const importNamespaceSpecifierCondition =\n              path.node.callee.type === 'MemberExpression' &&\n              path.node.callee.property.type === 'Identifier' &&\n              path.node.callee.property.name === 'createServerFn'\n\n            const createServerFnEntryCondition =\n              identifierType === 'ImportSpecifier'\n                ? importSpecifierCondition\n                : importNamespaceSpecifierCondition\n\n            if (createServerFnEntryCondition) {\n              // If the function at createServerFn(_, MyFunc) doesn't have a\n              // 'use server' directive at the top of the function scope,\n              // then add it.\n              const fn = path.node.arguments[1]\n\n              if (\n                t.isFunctionExpression(fn) ||\n                t.isArrowFunctionExpression(fn)\n              ) {\n                if (t.isBlockStatement(fn.body)) {\n                  const hasUseServerDirective = fn.body.directives.some(\n                    (directive) => {\n                      return directive.value.value === 'use server'\n                    },\n                  )\n\n                  if (!hasUseServerDirective) {\n                    fn.body.directives.unshift(\n                      t.directive(t.directiveLiteral('use server')),\n                    )\n                  }\n                }\n              } else if (t.isIdentifier(fn) || t.isCallExpression(fn)) {\n                // A function was passed to createServerFn in the form of an\n                // identifier or a call expression that returns a function.\n\n                // We wrap the identifier/call expression in a function\n                // expression that accepts the same arguments as the original\n                // function with the \"use server\" directive at the top of the\n                // function scope.\n\n                const args = t.restElement(t.identifier('args'))\n\n                // Annotate args with the type:\n                //  Parameters<Parameters<typeof createServerFn>[1]>\n\n                args.typeAnnotation = t.tsTypeAnnotation(\n                  t.tsTypeReference(\n                    t.identifier('Parameters'),\n                    t.tsTypeParameterInstantiation([\n                      t.tsIndexedAccessType(\n                        t.tsTypeReference(\n                          t.identifier('Parameters'),\n                          t.tsTypeParameterInstantiation([\n                            t.tsTypeQuery(t.identifier(serverFnId)),\n                          ]),\n                        ),\n                        t.tsLiteralType(t.numericLiteral(1)),\n                      ),\n                    ]),\n                  ),\n                )\n\n                const wrappedFn = t.arrowFunctionExpression(\n                  [args],\n                  t.blockStatement(\n                    [\n                      t.returnStatement(\n                        t.callExpression(\n                          t.memberExpression(fn, t.identifier('apply')),\n                          [t.identifier('this'), t.identifier('args')],\n                        ),\n                      ),\n                    ],\n                    [t.directive(t.directiveLiteral('use server'))],\n                  ),\n                )\n\n                path.node.arguments[1] = wrappedFn\n              }\n            }\n          },\n        })\n      },\n    },\n  })\n\n  return generate(ast, {\n    sourceMaps: true,\n    minified: process.env.NODE_ENV === 'production',\n  })\n}\n"],"names":[],"mappings":"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"}