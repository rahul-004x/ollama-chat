import * as babel from "@babel/core";
import * as t from "@babel/types";
import _generate from "@babel/generator";
import { deadCodeElimination } from "babel-dead-code-elimination";
import { parseAst } from "./ast.js";
let generate = _generate["default"];
if (!generate) {
  generate = _generate;
}
function compileEliminateDeadCode(opts) {
  const ast = parseAst(opts);
  if (!ast) {
    throw new Error(
      `Failed to compile ast for compileEliminateDeadCode() for the file: ${opts.filename}`
    );
  }
  deadCodeElimination(ast);
  return generate(ast, {
    sourceMaps: true
  });
}
function compileCreateServerFnOutput(opts) {
  const ast = parseAst(opts);
  if (!ast) {
    throw new Error(
      `Failed to compile ast for compileCreateServerFnOutput() for the file: ${opts.filename}`
    );
  }
  babel.traverse(ast, {
    Program: {
      enter(programPath) {
        let identifierType = "ImportSpecifier";
        let namespaceId = "";
        let serverFnId = "createServerFn";
        programPath.traverse({
          ImportDeclaration: (path) => {
            if (path.node.source.value !== "@tanstack/start") {
              return;
            }
            path.node.specifiers.forEach((specifier) => {
              if (specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier") {
                if (specifier.imported.name === "createServerFn") {
                  serverFnId = specifier.local.name;
                  identifierType = "ImportSpecifier";
                }
              }
              if (specifier.type === "ImportNamespaceSpecifier") {
                identifierType = "ImportNamespaceSpecifier";
                namespaceId = specifier.local.name;
                serverFnId = `${namespaceId}.createServerFn`;
              }
            });
          },
          CallExpression: (path) => {
            const importSpecifierCondition = path.node.callee.type === "Identifier" && path.node.callee.name === serverFnId;
            const importNamespaceSpecifierCondition = path.node.callee.type === "MemberExpression" && path.node.callee.property.type === "Identifier" && path.node.callee.property.name === "createServerFn";
            const createServerFnEntryCondition = identifierType === "ImportSpecifier" ? importSpecifierCondition : importNamespaceSpecifierCondition;
            if (createServerFnEntryCondition) {
              const fn = path.node.arguments[1];
              if (t.isFunctionExpression(fn) || t.isArrowFunctionExpression(fn)) {
                if (t.isBlockStatement(fn.body)) {
                  const hasUseServerDirective = fn.body.directives.some(
                    (directive) => {
                      return directive.value.value === "use server";
                    }
                  );
                  if (!hasUseServerDirective) {
                    fn.body.directives.unshift(
                      t.directive(t.directiveLiteral("use server"))
                    );
                  }
                }
              } else if (t.isIdentifier(fn) || t.isCallExpression(fn)) {
                const args = t.restElement(t.identifier("args"));
                args.typeAnnotation = t.tsTypeAnnotation(
                  t.tsTypeReference(
                    t.identifier("Parameters"),
                    t.tsTypeParameterInstantiation([
                      t.tsIndexedAccessType(
                        t.tsTypeReference(
                          t.identifier("Parameters"),
                          t.tsTypeParameterInstantiation([
                            t.tsTypeQuery(t.identifier(serverFnId))
                          ])
                        ),
                        t.tsLiteralType(t.numericLiteral(1))
                      )
                    ])
                  )
                );
                const wrappedFn = t.arrowFunctionExpression(
                  [args],
                  t.blockStatement(
                    [
                      t.returnStatement(
                        t.callExpression(
                          t.memberExpression(fn, t.identifier("apply")),
                          [t.identifier("this"), t.identifier("args")]
                        )
                      )
                    ],
                    [t.directive(t.directiveLiteral("use server"))]
                  )
                );
                path.node.arguments[1] = wrappedFn;
              }
            }
          }
        });
      }
    }
  });
  return generate(ast, {
    sourceMaps: true,
    minified: process.env.NODE_ENV === "production"
  });
}
export {
  compileCreateServerFnOutput,
  compileEliminateDeadCode
};
//# sourceMappingURL=compilers.js.map
